/**
 * Project Bundler
 * 
 * Creates ZIP bundles for project export with all necessary files
 * for a zero-cleanup, drop-in-ready Hono/JSX project.
 */

import { createExportBundle, type ExportBundle } from './serializer';
import type { ASTComponent } from '../nudge-engine/patcher';

/** Tailwind v4 CSS directives */
const TAILWIND_DIRECTIVES = `@import "tailwindcss";

/* Custom vibe theme variables */
@theme {
  /* Vibe CSS variables will be injected below */
}
`;

/** Package.json template for exported project */
const PACKAGE_JSON_TEMPLATE = {
  name: '02-export',
  type: 'module',
  scripts: {
    dev: 'bunx --bun vite',
    build: 'bunx --bun vite build',
    preview: 'bunx --bun vite preview',
  },
  dependencies: {
    hono: '^4.11.4',
  },
  devDependencies: {
    '@tailwindcss/vite': '^4.0.0',
    tailwindcss: '^4.0.0',
    typescript: '^5.0.0',
    vite: '^6.3.5',
  },
};

/** Vite config template */
const VITE_CONFIG = `import { defineConfig } from 'vite';
import tailwindcss from '@tailwindcss/vite';

export default defineConfig({
  plugins: [tailwindcss()],
  esbuild: {
    jsxImportSource: 'hono/jsx',
    jsx: 'automatic',
  },
});
`;

/** TSConfig template */
const TSCONFIG = `{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "jsx": "react-jsx",
    "jsxImportSource": "hono/jsx",
    "strict": true,
    "skipLibCheck": true
  },
  "include": ["src"]
}
`;

/** Main entry point template */
const MAIN_TEMPLATE = `import { Hono } from 'hono';
import './styles.css';

// Import generated components
import * as Components from './components';

const app = new Hono();

// Mount your components as routes
app.get('/', (c) => {
  // Vite handles CSS bundling in dev/build - no separate static serve needed
  return c.html(\`
    <!DOCTYPE html>
    <html>
      <head>
        <title>02 Export</title>
        <script type="module" src="/src/main.tsx"></script>
      </head>
      <body>
        <div id="app">
          <!-- Mount your components here -->
        </div>
      </body>
    </html>
  \`);
});

export default app;
`;

/** Project bundle contents */
export interface ProjectBundle {
  files: Map<string, Uint8Array>;
  manifest: BundleManifest;
}

/** Bundle manifest for tracking contents */
export interface BundleManifest {
  vibeId: string;
  componentCount: number;
  createdAt: string;
  files: string[];
}

/**
 * Create the full styles.css with Tailwind directives and vibe CSS
 */
export function createStylesFile(vibeCss: string): string {
  // Merge Tailwind directives with vibe CSS
  return `${TAILWIND_DIRECTIVES}

/* Vibe Theme */
${vibeCss}
`;
}

/**
 * Encode string to UTF-8 Uint8Array
 */
function encodeUtf8(str: string): Uint8Array {
  return new TextEncoder().encode(str);
}

/**
 * Create a complete project bundle with all necessary files
 */
export function createProjectBundle(
  components: Record<string, ASTComponent>,
  vibeId: string,
  vibeCss: string
): ProjectBundle {
  const files = new Map<string, Uint8Array>();
  
  // Get component export files
  const exportBundle = createExportBundle(components, vibeId, vibeCss);
  
  // Add component files to src directory
  for (const file of exportBundle) {
    const path = file.filename === 'vibe.css' 
      ? `src/${file.filename}` 
      : `src/${file.filename}`;
    files.set(path, encodeUtf8(file.content));
  }
  
  // Add styles.css with Tailwind directives
  files.set('src/styles.css', encodeUtf8(createStylesFile(vibeCss)));
  
  // Add main entry point
  files.set('src/main.tsx', encodeUtf8(MAIN_TEMPLATE));
  
  // Add config files
  files.set('package.json', encodeUtf8(JSON.stringify(PACKAGE_JSON_TEMPLATE, null, 2)));
  files.set('vite.config.ts', encodeUtf8(VITE_CONFIG));
  files.set('tsconfig.json', encodeUtf8(TSCONFIG));
  
  // Add README
  const readme = `# 02 Export - ${vibeId}

Generated by 02 Builder on ${new Date().toISOString()}

## Getting Started

1. Install dependencies:
   \`\`\`bash
   bun install
   \`\`\`

2. Start development server:
   \`\`\`bash
   bun run dev
   \`\`\`

3. Build for production:
   \`\`\`bash
   bun run build
   \`\`\`

## Files

- \`src/components.tsx\` - Generated components
- \`src/styles.css\` - Tailwind CSS with vibe theme
- \`src/main.tsx\` - Application entry point

## Vibe

This project uses the "${vibeId}" vibe theme.
`;
  files.set('README.md', encodeUtf8(readme));
  
  // Create manifest
  const manifest: BundleManifest = {
    vibeId,
    componentCount: Object.keys(components).length,
    createdAt: new Date().toISOString(),
    files: Array.from(files.keys()),
  };
  
  return { files, manifest };
}

/**
 * Create a simple ZIP file from the project bundle
 * 
 * This is a minimal ZIP implementation for browser/edge environments
 * without external dependencies. For production, consider using a library
 * like fflate or jszip.
 */
export function createZipFile(bundle: ProjectBundle): Uint8Array {
  const entries: Array<{ path: string; data: Uint8Array }> = [];
  
  for (const [path, data] of bundle.files) {
    entries.push({ path, data });
  }
  
  // Calculate sizes
  let offset = 0;
  const centralDirectory: Uint8Array[] = [];
  const localFiles: Uint8Array[] = [];
  
  for (const entry of entries) {
    const pathBytes = encodeUtf8(entry.path);
    const dataLen = entry.data.length;
    
    // Local file header (30 bytes + path length)
    const localHeader = new Uint8Array(30 + pathBytes.length);
    const localView = new DataView(localHeader.buffer);
    
    // Local file header signature
    localView.setUint32(0, 0x04034b50, true);
    // Version needed to extract
    localView.setUint16(4, 20, true);
    // General purpose bit flag
    localView.setUint16(6, 0, true);
    // Compression method (0 = stored/no compression)
    localView.setUint16(8, 0, true);
    // Last mod file time
    localView.setUint16(10, 0, true);
    // Last mod file date
    localView.setUint16(12, 0, true);
    // CRC-32 (we'll use 0 for simplicity - not ideal but works)
    localView.setUint32(14, crc32(entry.data), true);
    // Compressed size
    localView.setUint32(18, dataLen, true);
    // Uncompressed size
    localView.setUint32(22, dataLen, true);
    // File name length
    localView.setUint16(26, pathBytes.length, true);
    // Extra field length
    localView.setUint16(28, 0, true);
    // File name
    localHeader.set(pathBytes, 30);
    
    // Central directory entry (46 bytes + path length)
    const centralEntry = new Uint8Array(46 + pathBytes.length);
    const centralView = new DataView(centralEntry.buffer);
    
    // Central file header signature
    centralView.setUint32(0, 0x02014b50, true);
    // Version made by
    centralView.setUint16(4, 20, true);
    // Version needed to extract
    centralView.setUint16(6, 20, true);
    // General purpose bit flag
    centralView.setUint16(8, 0, true);
    // Compression method
    centralView.setUint16(10, 0, true);
    // Last mod file time
    centralView.setUint16(12, 0, true);
    // Last mod file date
    centralView.setUint16(14, 0, true);
    // CRC-32
    centralView.setUint32(16, crc32(entry.data), true);
    // Compressed size
    centralView.setUint32(20, dataLen, true);
    // Uncompressed size
    centralView.setUint32(24, dataLen, true);
    // File name length
    centralView.setUint16(28, pathBytes.length, true);
    // Extra field length
    centralView.setUint16(30, 0, true);
    // File comment length
    centralView.setUint16(32, 0, true);
    // Disk number start
    centralView.setUint16(34, 0, true);
    // Internal file attributes
    centralView.setUint16(36, 0, true);
    // External file attributes
    centralView.setUint32(38, 0, true);
    // Relative offset of local header
    centralView.setUint32(42, offset, true);
    // File name
    centralEntry.set(pathBytes, 46);
    
    localFiles.push(localHeader);
    localFiles.push(entry.data);
    centralDirectory.push(centralEntry);
    
    offset += localHeader.length + entry.data.length;
  }
  
  // End of central directory record (22 bytes)
  const centralDirSize = centralDirectory.reduce((sum, entry) => sum + entry.length, 0);
  const endRecord = new Uint8Array(22);
  const endView = new DataView(endRecord.buffer);
  
  // End of central dir signature
  endView.setUint32(0, 0x06054b50, true);
  // Number of this disk
  endView.setUint16(4, 0, true);
  // Disk where central directory starts
  endView.setUint16(6, 0, true);
  // Number of central directory records on this disk
  endView.setUint16(8, entries.length, true);
  // Total number of central directory records
  endView.setUint16(10, entries.length, true);
  // Size of central directory
  endView.setUint32(12, centralDirSize, true);
  // Offset of start of central directory
  endView.setUint32(16, offset, true);
  // Comment length
  endView.setUint16(20, 0, true);
  
  // Combine all parts
  const totalSize = offset + centralDirSize + 22;
  const zip = new Uint8Array(totalSize);
  let pos = 0;
  
  for (const part of localFiles) {
    zip.set(part, pos);
    pos += part.length;
  }
  
  for (const part of centralDirectory) {
    zip.set(part, pos);
    pos += part.length;
  }
  
  zip.set(endRecord, pos);
  
  return zip;
}

/**
 * CRC-32 implementation for ZIP file integrity
 */
function crc32(data: Uint8Array): number {
  // Pre-computed CRC-32 table
  const table = new Uint32Array(256);
  for (let i = 0; i < 256; i++) {
    let c = i;
    for (let j = 0; j < 8; j++) {
      c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
    }
    table[i] = c;
  }
  
  let crc = 0xFFFFFFFF;
  for (let i = 0; i < data.length; i++) {
    crc = table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
  }
  return (crc ^ 0xFFFFFFFF) >>> 0;
}

/**
 * Generate a download filename for the export
 */
export function generateExportFilename(vibeId: string): string {
  const timestamp = new Date().toISOString().split('T')[0];
  return `02-export-${vibeId}-${timestamp}.zip`;
}
